var timeBrowser = {
    mobile: function () {
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))
            return true;
        else
            return false;
    },
    apple: function () {
        if (/iPhone|iPad|iPod/i.test(navigator.userAgent))
            return true;
        else
            return false;
    },
    android: function () {
        if (/Android/i.test(navigator.userAgent)) {
            //check android is on mobile or tablet.
            var userAgentString = navigator.userAgent.toLowerCase();
            if ((userAgentString.search("android") > -1) && (userAgentString.search("mobile") > -1))
                return true;
            else
                return false;
        } else
            return false;
    },
    phone: function () {
        if (/iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))
            return true;
        else
        if (/Android/i.test(navigator.userAgent)) {
            //check android is on mobile or tablet.
            var userAgentString = navigator.userAgent.toLowerCase();
            if ((userAgentString.search("android") > -1) && (userAgentString.search("mobile") > -1))
                return true;
            else
                return false;
        } else
            return false;
    }

}

var timeAjax = {
    fail: function (jqXHR, textStatus, errorThrown) {
        console.log("Sorry, Error Occur !");
    },
    get: function (url, param, callback, $header, returnDataType) {
        if (!returnDataType)
            returnDataType = 'text';
        //callback is only use for easy request, for example load html
        var jqxhr = $.get(url, param, undefined, returnDataType);
        jqxhr.done(function (data) {
            if (typeof (callback) === 'function')
                callback(data);
        });
        jqxhr.fail(function (jqXHR, textStatus) {
            timeAjax.fail(jqXHR, textStatus);
        });

    },
    post: function (url, param, callback, returnDataType, sendDataType) {
        if (!param)
            param = {};
        if (!returnDataType)
            returnDataType = 'json';
        if (!sendDataType)
            sendDataType = 'application/json; charset=UTF-8';
        $.ajax({
            type: 'POST',
            url: url,
            data: JSON.stringify(param),
            contentType: sendDataType,
            dataType: returnDataType,
        }).done(function (data) {
            if (typeof (callback) === 'function')
                callback(data);

        }).fail(function (jqXHR, textStatus) {
            timeAjax.fail(jqXHR, textStatus);
        });
    }
};


var ipPath = 'http://127.0.0.1:3000';
//var ipPath = 'http://ec2-52-37-155-150.us-west-2.compute.amazonaws.com';

var getAllUserCallback = function (data) {
    $('#user').append('<div>' + data.firstName + '<div>');
    $('#user').append('<div>' + data.lastName + '<div>');
    $('#user').append('<div>' + data.email + '<div>');
}

$(function () {
    var url = '/user/getAllUsers';
    timeAjax.post(ipPath + url, {}, getAllUserCallback);
});

var Comment = React.createClass({
    rawMarkup: function () {
        var rawMarkup = marked(this.props.children.toString(), {
            sanitize: true
        });
        return {
            __html: rawMarkup
        };
    },

    render: function () {
        return ( < div className = "comment" >
            < h2 className = "commentAuthor" > {
                this.props.author
            } < /h2> < span dangerouslySetInnerHTML = {
            this.rawMarkup()
        }
        /> < /div >
    );
}
});

var CommentBox = React.createClass({
    loadCommentsFromServer: function () {

    },
    handleCommentSubmit: function (comment) {
        var comments = this.state.data;
        // Optimistically set an id on the new comment. It will be replaced by an
        // id generated by the server. In a production application you would likely
        // not use Date.now() for this and would have a more robust system in place.
        comment.id = Date.now();
        var newComments = comments.concat([comment]);
        this.setState({
            data: newComments
        });

    },
    getInitialState: function () {
        return {
            data: []
        };
    },
    componentDidMount: function () {
        this.loadCommentsFromServer();
        setInterval(this.loadCommentsFromServer, this.props.pollInterval);
    },
    render: function () {
        return ( < div className = "commentBox" >
            < h1 > Comments < /h1> < CommentList data = {
            this.state.data
        }
        /> < CommentForm onCommentSubmit = {
        this.handleCommentSubmit
    }
    /> < /div >
);
}
});

var CommentList = React.createClass({
            render: function () {
                var commentNodes = this.props.data.map(function (comment) {
                    return ( < Comment author = {
                            comment.author
                        }
                        key = {
                            comment.id
                        } > {
                            comment.text
                        } < /Comment>
                    );
                });
                return ( < div className = "commentList" > {
                        commentNodes
                    } < /div>);
                }
            });

        var CommentForm = React.createClass({
            getInitialState: function () {
                return {
                    author: '',
                    text: ''
                };
            },
            handleAuthorChange: function (e) {
                this.setState({
                    author: e.target.value
                });
            },
            handleTextChange: function (e) {
                this.setState({
                    text: e.target.value
                });
            },
            handleSubmit: function (e) {
                e.preventDefault();
                var author = this.state.author.trim();
                var text = this.state.text.trim();
                if (!text || !author) {
                    return;
                }
                this.props.onCommentSubmit({
                    author: author,
                    text: text
                });
                this.setState({
                    author: '',
                    text: ''
                });
            },
            render: function () {
                return ( < form className = "commentForm"
                    onSubmit = {
                        this.handleSubmit
                    } >
                    < input type = "text"
                    placeholder = "Your name"
                    value = {
                        this.state.author
                    }
                    onChange = {
                        this.handleAuthorChange
                    }
                    /> < input type = "text"
                    placeholder = "Say something..."
                    value = {
                        this.state.text
                    }
                    onChange = {
                        this.handleTextChange
                    }
                    /> < input type = "submit"
                    value = "Post" / >
                    < /form>
                );
            }
        });

        ReactDOM.render( < CommentBox url = "/api/comments"
            pollInterval = {
                2000
            }
            />,
            document.getElementById('content')
        );